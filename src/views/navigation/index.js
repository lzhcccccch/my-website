/**
 * ‰∏™‰∫∫ÂØºËà™Á´ôÂäüËÉΩÊ®°ÂùóÂÖ•Âè£Êñá‰ª∂
 * Áªü‰∏ÄÂØºÂá∫ËØ•ÂäüËÉΩÊ®°ÂùóÁöÑÊâÄÊúâÁªÑ‰ª∂„ÄÅÊúçÂä°ÂíåÂ∑•ÂÖ∑
 */

// ‰∏ªË¶ÅÁªÑ‰ª∂
export { default as Navigation } from './index.vue'

// Á±ªÂûãÂÆö‰πâÂíåÂ∏∏Èáè
export {
  LinkCategories,
  LinkStatus,
  LinkPriority,
  SortOptions,
  ViewModes,
  ExportFormats,
  ValidationRules,
  ApiEndpoints,
  StorageKeys,
  DefaultConfig,
  DefaultCategories,
  EventNames,
  CssClasses,
  RouteNames,
  Permissions,
  LinkCheckStatus,
  StatisticsMetrics
} from './types/index'

/**
 * ÂäüËÉΩÊ®°ÂùóÂÖÉ‰ø°ÊÅØ
 */
export const FeatureInfo = {
  name: 'navigation',
  version: '1.0.0',
  description: '‰∏™‰∫∫ÂØºËà™Á´ô - Êî∂ÈõÜÂíåÊï¥ÁêÜÁΩëÁ´ôÈìæÊé•ÔºåÊâìÈÄ†‰∏™‰∫∫‰∏ìÂ±ûÂØºËà™È°µÈù¢',
  author: 'Stack Breeze',
  dependencies: ['vue', 'vue-router'],
  routes: [
    {
      path: '/navigation',
      name: 'Navigation',
      component: () => import('./index.vue')
    }
  ]
}

/**
 * ÂäüËÉΩÊ®°ÂùóÈÖçÁΩÆ
 */
export const FeatureConfig = {
  // ÊòØÂê¶ÂêØÁî®ËØ•ÂäüËÉΩÊ®°Âùó
  enabled: true,
  
  // ÂäüËÉΩÊ®°ÂùóÊùÉÈôêË¶ÅÊ±Ç
  permissions: ['links:read'],
  
  // ÂäüËÉΩÊ®°Âùó‰æùËµñÁöÑÂÖ∂‰ªñÊ®°Âùó
  dependencies: [],
  
  // ÂäüËÉΩÊ®°ÂùóÊèê‰æõÁöÑÊúçÂä°
  services: ['navigationApi', 'linkChecker', 'faviconService'],
  
  // ÂäüËÉΩÊ®°ÂùóÁöÑË∑ØÁî±ÈÖçÁΩÆ
  routing: {
    basePath: '/navigation',
    requiresAuth: false // Ê†πÊçÆÈúÄË¶ÅË∞ÉÊï¥
  },
  
  // ÂäüËÉΩÊ®°ÂùóÁöÑÂ≠òÂÇ®ÈÖçÁΩÆ
  storage: {
    namespace: 'navigation',
    keys: ['links', 'categories', 'preferences', 'statistics']
  },
  
  // ÂäüËÉΩÊ®°ÂùóÁöÑAPIÈÖçÁΩÆ
  api: {
    baseUrl: '/api/navigation',
    endpoints: {
      links: '/links',
      categories: '/categories',
      tags: '/tags',
      statistics: '/statistics',
      import: '/import',
      export: '/export'
    }
  },
  
  // ÈìæÊé•Ê£ÄÊü•ÈÖçÁΩÆ
  linkChecker: {
    enabled: true,
    interval: DefaultConfig.LINK_CHECK_INTERVAL,
    timeout: 10000, // 10Áßí
    retries: 3
  },
  
  // ÂõæÊ†áÊúçÂä°ÈÖçÁΩÆ
  faviconService: {
    enabled: DefaultConfig.ENABLE_FAVICON,
    fallbackIcon: 'üîó',
    cacheExpiry: 7 * 24 * 60 * 60 * 1000 // 7Â§©
  }
}

/**
 * ÂäüËÉΩÊ®°ÂùóÂàùÂßãÂåñÂáΩÊï∞
 * @param {Object} app - VueÂ∫îÁî®ÂÆû‰æã
 * @param {Object} options - ÂàùÂßãÂåñÈÄâÈ°π
 */
export function initializeNavigation(app, options = {}) {
  const config = { ...FeatureConfig, ...options }
  
  // Ê≥®ÂÜåÂÖ®Â±ÄÁªÑ‰ª∂ÔºàÂ¶ÇÊûúÈúÄË¶ÅÔºâ
  if (config.registerGlobalComponents) {
    app.component('Navigation', Navigation)
  }
  
  // ÂàùÂßãÂåñÂ≠òÂÇ®
  if (config.initializeStorage) {
    // ÂàùÂßãÂåñÊú¨Âú∞Â≠òÂÇ®
    // ÂàõÂª∫ÈªòËÆ§ÂàÜÁ±ª
    console.log('ÂàùÂßãÂåñÂØºËà™Á´ôÂ≠òÂÇ®...')
  }
  
  // ÂàùÂßãÂåñÈìæÊé•Ê£ÄÊü•Âô®
  if (config.initializeLinkChecker && config.linkChecker.enabled) {
    // ÂêØÂä®ÂÆöÊúüÈìæÊé•Ê£ÄÊü•
    console.log('ÂàùÂßãÂåñÈìæÊé•Ê£ÄÊü•Âô®...')
  }
  
  // ÂàùÂßãÂåñÂõæÊ†áÊúçÂä°
  if (config.initializeFaviconService && config.faviconService.enabled) {
    // ÂàùÂßãÂåñÂõæÊ†áÁºìÂ≠ò
    console.log('ÂàùÂßãÂåñÂõæÊ†áÊúçÂä°...')
  }
  
  // Ê≥®ÂÜå‰∫ã‰ª∂ÁõëÂê¨Âô®
  if (config.registerEventListeners) {
    // Ê≥®ÂÜåÂÖ®Â±Ä‰∫ã‰ª∂ÁõëÂê¨Âô®
    console.log('Ê≥®ÂÜåÂØºËà™Á´ô‰∫ã‰ª∂ÁõëÂê¨Âô®...')
  }
  
  console.log('‰∏™‰∫∫ÂØºËà™Á´ôÂäüËÉΩÊ®°ÂùóÂàùÂßãÂåñÂÆåÊàê')
  return config
}

/**
 * ÂäüËÉΩÊ®°ÂùóÊ∏ÖÁêÜÂáΩÊï∞
 */
export function cleanupNavigation() {
  // Ê∏ÖÁêÜ‰∫ã‰ª∂ÁõëÂê¨Âô®
  // Ê∏ÖÁêÜÂÆöÊó∂Âô®
  // Ê∏ÖÁêÜÁºìÂ≠ò
  // ÂÅúÊ≠¢ÈìæÊé•Ê£ÄÊü•
  console.log('‰∏™‰∫∫ÂØºËà™Á´ôÂäüËÉΩÊ®°ÂùóÊ∏ÖÁêÜÂÆåÊàê')
}

/**
 * Ëé∑ÂèñÂäüËÉΩÊ®°ÂùóÁä∂ÊÄÅ
 */
export function getNavigationStatus() {
  return {
    enabled: FeatureConfig.enabled,
    initialized: true,
    version: FeatureInfo.version,
    lastUpdated: new Date().toISOString(),
    statistics: {
      totalLinks: 0,
      activeLinks: 0,
      brokenLinks: 0,
      categoriesCount: 0
    }
  }
}

/**
 * ÈìæÊé•Ê£ÄÊü•Âô®Á±ª
 */
export class LinkChecker {
  constructor(options = {}) {
    this.options = { ...DefaultConfig, ...options }
    this.checkQueue = []
    this.isRunning = false
  }
  
  async checkLink(url) {
    try {
      const response = await fetch(url, {
        method: 'HEAD',
        mode: 'no-cors',
        timeout: this.options.timeout
      })
      
      return {
        url,
        status: LinkCheckStatus.SUCCESS,
        statusCode: response.status,
        checkedAt: new Date()
      }
    } catch (error) {
      return {
        url,
        status: LinkCheckStatus.FAILED,
        error: error.message,
        checkedAt: new Date()
      }
    }
  }
  
  async checkLinks(links) {
    const results = []
    
    for (const link of links) {
      const result = await this.checkLink(link.url)
      results.push({ ...link, checkResult: result })
    }
    
    return results
  }
  
  startPeriodicCheck(links, callback) {
    if (this.isRunning) return
    
    this.isRunning = true
    
    const checkInterval = setInterval(async () => {
      if (!this.isRunning) {
        clearInterval(checkInterval)
        return
      }
      
      const results = await this.checkLinks(links)
      callback(results)
    }, this.options.interval)
    
    return checkInterval
  }
  
  stopPeriodicCheck() {
    this.isRunning = false
  }
}

/**
 * ÂõæÊ†áÊúçÂä°Á±ª
 */
export class FaviconService {
  constructor(options = {}) {
    this.options = { ...DefaultConfig, ...options }
    this.cache = new Map()
  }
  
  getFaviconUrl(url) {
    try {
      const domain = new URL(url).hostname
      return `https://www.google.com/s2/favicons?domain=${domain}&sz=32`
    } catch (error) {
      return null
    }
  }
  
  async getFavicon(url) {
    // Ê£ÄÊü•ÁºìÂ≠ò
    if (this.cache.has(url)) {
      const cached = this.cache.get(url)
      if (Date.now() - cached.timestamp < this.options.cacheExpiry) {
        return cached.favicon
      }
    }
    
    // Ëé∑ÂèñÊñ∞ÂõæÊ†á
    const faviconUrl = this.getFaviconUrl(url)
    if (!faviconUrl) {
      return this.options.fallbackIcon
    }
    
    try {
      // È™åËØÅÂõæÊ†áÊòØÂê¶ÂèØÁî®
      const response = await fetch(faviconUrl, { method: 'HEAD' })
      if (response.ok) {
        // ÁºìÂ≠òÁªìÊûú
        this.cache.set(url, {
          favicon: faviconUrl,
          timestamp: Date.now()
        })
        return faviconUrl
      }
    } catch (error) {
      console.warn('Ëé∑ÂèñÂõæÊ†áÂ§±Ë¥•:', error)
    }
    
    return this.options.fallbackIcon
  }
  
  clearCache() {
    this.cache.clear()
  }
  
  getCacheSize() {
    return this.cache.size
  }
}

/**
 * ÂØºÂÖ•/ÂØºÂá∫Â∑•ÂÖ∑Á±ª
 */
export class ImportExportManager {
  constructor() {
    this.supportedFormats = Object.values(ExportFormats)
  }
  
  exportLinks(links, format = ExportFormats.JSON) {
    switch (format) {
      case ExportFormats.JSON:
        return this.exportToJSON(links)
      case ExportFormats.CSV:
        return this.exportToCSV(links)
      case ExportFormats.HTML:
        return this.exportToHTML(links)
      case ExportFormats.BOOKMARKS:
        return this.exportToBookmarks(links)
      default:
        throw new Error(`‰∏çÊîØÊåÅÁöÑÂØºÂá∫Ê†ºÂºè: ${format}`)
    }
  }
  
  exportToJSON(links) {
    return JSON.stringify(links, null, 2)
  }
  
  exportToCSV(links) {
    const headers = ['Ê†áÈ¢ò', 'ÈìæÊé•', 'ÂàÜÁ±ª', 'ÊèèËø∞', 'Ê†áÁ≠æ']
    const rows = links.map(link => [
      link.title,
      link.url,
      link.category,
      link.description || '',
      (link.tags || []).join(';')
    ])
    
    return [headers, ...rows]
      .map(row => row.map(cell => `"${cell}"`).join(','))
      .join('\n')
  }
  
  exportToHTML(links) {
    const groupedLinks = this.groupLinksByCategory(links)
    
    let html = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>‰∏™‰∫∫ÂØºËà™Á´ô</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .category { margin-bottom: 30px; }
        .category h2 { color: #333; border-bottom: 2px solid #ddd; }
        .link { margin: 10px 0; }
        .link a { text-decoration: none; color: #0066cc; }
        .link a:hover { text-decoration: underline; }
        .description { color: #666; font-size: 0.9em; margin-left: 20px; }
    </style>
</head>
<body>
    <h1>‰∏™‰∫∫ÂØºËà™Á´ô</h1>
`
    
    for (const [category, categoryLinks] of Object.entries(groupedLinks)) {
      html += `    <div class="category">
        <h2>${category}</h2>
`
      
      for (const link of categoryLinks) {
        html += `        <div class="link">
            <a href="${link.url}" target="_blank">${link.title}</a>
            ${link.description ? `<div class="description">${link.description}</div>` : ''}
        </div>
`
      }
      
      html += `    </div>
`
    }
    
    html += `</body>
</html>`
    
    return html
  }
  
  exportToBookmarks(links) {
    // ÁîüÊàêÊµèËßàÂô®‰π¶Á≠æÊ†ºÂºè
    let bookmarks = `<!DOCTYPE NETSCAPE-Bookmark-file-1>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Bookmarks</TITLE>
<H1>Bookmarks</H1>
<DL><p>
`
    
    const groupedLinks = this.groupLinksByCategory(links)
    
    for (const [category, categoryLinks] of Object.entries(groupedLinks)) {
      bookmarks += `    <DT><H3>${category}</H3>
    <DL><p>
`
      
      for (const link of categoryLinks) {
        bookmarks += `        <DT><A HREF="${link.url}">${link.title}</A>
`
      }
      
      bookmarks += `    </DL><p>
`
    }
    
    bookmarks += `</DL><p>`
    
    return bookmarks
  }
  
  groupLinksByCategory(links) {
    return links.reduce((groups, link) => {
      const category = link.category || 'Êú™ÂàÜÁ±ª'
      if (!groups[category]) {
        groups[category] = []
      }
      groups[category].push(link)
      return groups
    }, {})
  }
  
  async importLinks(data, format = ExportFormats.JSON) {
    switch (format) {
      case ExportFormats.JSON:
        return this.importFromJSON(data)
      case ExportFormats.CSV:
        return this.importFromCSV(data)
      case ExportFormats.BOOKMARKS:
        return this.importFromBookmarks(data)
      default:
        throw new Error(`‰∏çÊîØÊåÅÁöÑÂØºÂÖ•Ê†ºÂºè: ${format}`)
    }
  }
  
  importFromJSON(data) {
    try {
      const links = JSON.parse(data)
      return Array.isArray(links) ? links : []
    } catch (error) {
      throw new Error('JSON Ê†ºÂºèÈîôËØØ')
    }
  }
  
  importFromCSV(data) {
    const lines = data.split('\n').filter(line => line.trim())
    const headers = lines[0].split(',').map(h => h.replace(/"/g, ''))
    
    return lines.slice(1).map(line => {
      const values = line.split(',').map(v => v.replace(/"/g, ''))
      return {
        title: values[0] || '',
        url: values[1] || '',
        category: values[2] || 'Êú™ÂàÜÁ±ª',
        description: values[3] || '',
        tags: values[4] ? values[4].split(';') : []
      }
    })
  }
  
  importFromBookmarks(data) {
    // ÁÆÄÂçïÁöÑ‰π¶Á≠æËß£ÊûêÔºàÂÆûÈôÖÂÆûÁé∞ÂèØËÉΩÈúÄË¶ÅÊõ¥Â§çÊùÇÁöÑHTMLËß£ÊûêÔºâ
    const links = []
    const linkRegex = /<A HREF="([^"]+)"[^>]*>([^<]+)<\/A>/gi
    let match
    
    while ((match = linkRegex.exec(data)) !== null) {
      links.push({
        title: match[2],
        url: match[1],
        category: 'ÂØºÂÖ•ÁöÑ‰π¶Á≠æ',
        description: '',
        tags: []
      })
    }
    
    return links
  }
}

// ÈªòËÆ§ÂØºÂá∫‰∏ªÁªÑ‰ª∂
export default Navigation
